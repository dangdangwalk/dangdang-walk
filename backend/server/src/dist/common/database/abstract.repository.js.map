{"version":3,"sources":["../../../src/common/database/abstract.repository.ts"],"sourcesContent":["import { ConflictException, NotFoundException } from '@nestjs/common';\nimport {\n    DeleteResult,\n    EntityManager,\n    FindManyOptions,\n    FindOneOptions,\n    FindOptionsWhere,\n    InsertResult,\n    ObjectLiteral,\n    Repository,\n    UpdateResult,\n} from 'typeorm';\nimport { QueryDeepPartialEntity } from 'typeorm/query-builder/QueryPartialEntity';\n\nexport abstract class AbstractRepository<T extends ObjectLiteral> {\n    constructor(\n        private readonly entityRepository: Repository<T>,\n        private readonly entityManager: EntityManager,\n    ) {}\n\n    async create(entity: T): Promise<T> {\n        return this.entityRepository.save(entity);\n    }\n\n    /**\n     * 주어진 entity가 이미 존재하는지 확인하고, 존재하지 않으면 새로운 entity를 생성하는 비동기 함수입니다.\n     *\n     * @param entity database에 저장하려는 새로운 entity입니다.\n     * @param attributes entity를 식별하는 데 사용할 column(또는 속성)의 이름 또는 이름의 배열입니다.\n     * 여러 개의 column을 지정하면 해당하는 조건이 모두 일치해야 기존 entity로 간주됩니다.\n     * @returns entity가 성공적으로 생성되면 생성된 entity가 반환됩니다.\n     */\n    async createIfNotExists(entity: T, attributes: keyof T | (keyof T)[]): Promise<T> {\n        const attributeList = Array.isArray(attributes) ? attributes : [attributes];\n\n        const where: Partial<T> = {};\n        for (const attribute of attributeList) {\n            where[attribute] = entity[attribute];\n        }\n\n        const existingEntity = await this.entityRepository.findOne({ where });\n\n        if (existingEntity) {\n            throw new ConflictException('createIfNotExists: 이미 존재하는 레코드입니다');\n        }\n\n        return this.create(entity);\n    }\n\n    async insert(entity: QueryDeepPartialEntity<T> | QueryDeepPartialEntity<T>[]): Promise<InsertResult> {\n        return this.entityRepository.insert(entity);\n    }\n\n    async findOneWithNoException(where: FindOptionsWhere<T>): Promise<T | null> {\n        return this.entityRepository.findOne({ where });\n    }\n\n    async findOne(where: FindOneOptions<T>): Promise<T> {\n        const entity = await this.entityRepository.findOne(where);\n\n        if (!entity) {\n            throw new NotFoundException('findOne: 존재하지 않는 레코드입니다');\n        }\n\n        return entity;\n    }\n\n    async find(where: FindManyOptions<T>): Promise<T[]> {\n        const result = this.entityRepository.find(where);\n\n        if (!result) {\n            throw new NotFoundException('find: 존재하지 않는 레코드입니다');\n        }\n\n        return result;\n    }\n\n    async update(where: FindOptionsWhere<T>, partialEntity: QueryDeepPartialEntity<T>): Promise<UpdateResult> {\n        const updateResult = await this.entityRepository.update(where, partialEntity);\n\n        if (!updateResult.affected) {\n            throw new NotFoundException('update: 존재하지 않는 레코드입니다');\n        }\n\n        return updateResult;\n    }\n\n    async delete(where: FindOptionsWhere<T>): Promise<DeleteResult> {\n        const deleteResult = await this.entityRepository.delete(where);\n\n        if (!deleteResult.affected) {\n            throw new NotFoundException('delete: 존재하지 않는 레코드입니다');\n        }\n\n        return deleteResult;\n    }\n\n    async updateAndFindOne(where: FindOptionsWhere<T>, partialEntity: QueryDeepPartialEntity<T>): Promise<T> {\n        const updateResult = await this.entityRepository.update(where, partialEntity);\n\n        if (!updateResult.affected) {\n            throw new NotFoundException('update: 존재하지 않는 레코드입니다');\n        }\n        const options: FindOneOptions = { where };\n\n        return this.findOne(options);\n    }\n}\n"],"names":["AbstractRepository","create","entity","entityRepository","save","createIfNotExists","attributes","attributeList","Array","isArray","where","attribute","existingEntity","findOne","ConflictException","insert","findOneWithNoException","NotFoundException","find","result","update","partialEntity","updateResult","affected","delete","deleteResult","updateAndFindOne","options","constructor","entityManager"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";+BAcsBA;;;eAAAA;;;wBAd+B;AAc9C,IAAA,AAAeA,qBAAf,MAAeA;IAMlB,MAAMC,OAAOC,MAAS,EAAc;QAChC,OAAO,IAAI,CAACC,gBAAgB,CAACC,IAAI,CAACF;IACtC;IAEA;;;;;;;KAOC,GACD,MAAMG,kBAAkBH,MAAS,EAAEI,UAAiC,EAAc;QAC9E,MAAMC,gBAAgBC,MAAMC,OAAO,CAACH,cAAcA,aAAa;YAACA;SAAW;QAE3E,MAAMI,QAAoB,CAAC;QAC3B,KAAK,MAAMC,aAAaJ,cAAe;YACnCG,KAAK,CAACC,UAAU,GAAGT,MAAM,CAACS,UAAU;QACxC;QAEA,MAAMC,iBAAiB,MAAM,IAAI,CAACT,gBAAgB,CAACU,OAAO,CAAC;YAAEH;QAAM;QAEnE,IAAIE,gBAAgB;YAChB,MAAM,IAAIE,yBAAiB,CAAC;QAChC;QAEA,OAAO,IAAI,CAACb,MAAM,CAACC;IACvB;IAEA,MAAMa,OAAOb,MAA+D,EAAyB;QACjG,OAAO,IAAI,CAACC,gBAAgB,CAACY,MAAM,CAACb;IACxC;IAEA,MAAMc,uBAAuBN,KAA0B,EAAqB;QACxE,OAAO,IAAI,CAACP,gBAAgB,CAACU,OAAO,CAAC;YAAEH;QAAM;IACjD;IAEA,MAAMG,QAAQH,KAAwB,EAAc;QAChD,MAAMR,SAAS,MAAM,IAAI,CAACC,gBAAgB,CAACU,OAAO,CAACH;QAEnD,IAAI,CAACR,QAAQ;YACT,MAAM,IAAIe,yBAAiB,CAAC;QAChC;QAEA,OAAOf;IACX;IAEA,MAAMgB,KAAKR,KAAyB,EAAgB;QAChD,MAAMS,SAAS,IAAI,CAAChB,gBAAgB,CAACe,IAAI,CAACR;QAE1C,IAAI,CAACS,QAAQ;YACT,MAAM,IAAIF,yBAAiB,CAAC;QAChC;QAEA,OAAOE;IACX;IAEA,MAAMC,OAAOV,KAA0B,EAAEW,aAAwC,EAAyB;QACtG,MAAMC,eAAe,MAAM,IAAI,CAACnB,gBAAgB,CAACiB,MAAM,CAACV,OAAOW;QAE/D,IAAI,CAACC,aAAaC,QAAQ,EAAE;YACxB,MAAM,IAAIN,yBAAiB,CAAC;QAChC;QAEA,OAAOK;IACX;IAEA,MAAME,OAAOd,KAA0B,EAAyB;QAC5D,MAAMe,eAAe,MAAM,IAAI,CAACtB,gBAAgB,CAACqB,MAAM,CAACd;QAExD,IAAI,CAACe,aAAaF,QAAQ,EAAE;YACxB,MAAM,IAAIN,yBAAiB,CAAC;QAChC;QAEA,OAAOQ;IACX;IAEA,MAAMC,iBAAiBhB,KAA0B,EAAEW,aAAwC,EAAc;QACrG,MAAMC,eAAe,MAAM,IAAI,CAACnB,gBAAgB,CAACiB,MAAM,CAACV,OAAOW;QAE/D,IAAI,CAACC,aAAaC,QAAQ,EAAE;YACxB,MAAM,IAAIN,yBAAiB,CAAC;QAChC;QACA,MAAMU,UAA0B;YAAEjB;QAAM;QAExC,OAAO,IAAI,CAACG,OAAO,CAACc;IACxB;IA3FAC,YACI,AAAiBzB,gBAA+B,EAChD,AAAiB0B,aAA4B,CAC/C;aAFmB1B,mBAAAA;aACA0B,gBAAAA;IAClB;AAyFP"}