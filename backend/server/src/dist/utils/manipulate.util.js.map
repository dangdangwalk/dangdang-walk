{"version":3,"sources":["../../src/utils/manipulate.util.ts"],"sourcesContent":["/**\n * 주어진 배열에 값이나 값의 배열이 존재하는지 확인합니다.\n *\n * 이 함수는 배열의 어떤 타입에도 작동할 수 있는 제네릭 함수입니다.\n * `targetArr` 매개변수를 통해 검색할 배열을 받고, `toFind` 매개변수를 통해 검색할 값이나 값의 배열을 받습니다.\n *\n * 함수는 [`toFind`가 `targetArr`에 존재하는지 여부, 존재하지 않는 값 배열]을 반환합니다.\n *\n * @template T - `targetArr`와 `toFind`의 요소 타입.\n * @param targetArr - 검색할 배열.\n * @param toFind - 검색할 값이나 값의 배열.\n * @returns [`toFind`가 `targetArr`에 존재하는지 여부, 존재하지 않는 값 배열]\n *\n **/\nexport function checkIfExistsInArr<T>(targetArr: T[], toFind: T | T[]): [boolean, T[]] {\n    const toFindList = Array.isArray(toFind) ? toFind : [toFind];\n\n    const notFound = toFindList.filter((cur) => !targetArr.includes(cur));\n\n    return [notFound.length === 0, notFound];\n}\n\n/**\n * 주어진 배열의 각 요소에서 특정 속성을 선택하여 새로운 객체를 만듭니다.\n * 이때, 새로운 객체의 키로는 `targetAttributes` 배열의 값들이 사용되고,\n * 값으로는 `srcAttributes` 배열의 값들이 사용됩니다.\n * 생성된 객체들은 최종 결과 배열에 추가됩니다.\n *\n * @param {any[]} targetArr - 속성을 추출할 소스 배열입니다.\n * @param {(string|string[])} newAttributes - 결과 객체의 키로 사용할 속성 이름입니다.\n * 단일 문자열 또는 속성 이름의 배열을 받을 수 있습니다.\n * @param {(string|string[])} srcAttributes - 소스 배열의 각 요소에서 속성을 추출할 속성 이름입니다.\n * 단일 문자열 또는 속성 이름의 배열을 받을 수 있습니다.\n * @returns {any[]} 결과 객체들의 배열입니다.\n **/\n\nexport function makeSubObjectsArray(\n    targetArr: any[],\n    srcAttributes: string | string[],\n    newAttributes?: string | string[],\n): any[] {\n    const resArr: any[] = [];\n    newAttributes = newAttributes ?? srcAttributes;\n    Array.isArray(srcAttributes) ? srcAttributes : [srcAttributes];\n    Array.isArray(newAttributes) ? newAttributes : [newAttributes];\n\n    if (srcAttributes.length != newAttributes.length) {\n        throw new Error('srcAttributes와 targetAttributes의 길이가 다릅니다');\n    }\n    targetArr.map((cur) => {\n        const obj: { [key: string]: any } = {};\n        for (let i = 0; i < srcAttributes.length; i++) {\n            obj[`${srcAttributes[i]}`] = cur[`${newAttributes[i]}`];\n        }\n        resArr.push(obj);\n    });\n    return resArr;\n}\n\n/**\n * 주어진 타겟 객체에서 지정된 속성만을 포함하는 새 객체를 생성합니다.\n *\n * @param target - 속성을 추출할 원본 객체입니다.\n * @param attributes - 새 객체에 포함할 속성 이름의 배열입니다.\n * @returns 타겟 객체에서 지정된 속성만을 포함하는 새 객체입니다.\n *\n */\nexport function makeSubObject(target: any, attributes: string[]): any {\n    const resObj: { [key: string]: any } = {};\n    for (let i = 0; i < attributes.length; i++) {\n        resObj[`${attributes[i]}`] = target[`${attributes[i]}`];\n    }\n    return resObj;\n}\n"],"names":["checkIfExistsInArr","makeSubObject","makeSubObjectsArray","targetArr","toFind","toFindList","Array","isArray","notFound","filter","cur","includes","length","srcAttributes","newAttributes","resArr","Error","map","obj","i","push","target","attributes","resObj"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"AAAA;;;;;;;;;;;;;EAaE;;;;;;;;IACcA,kBAAkB;eAAlBA;;IAqDAC,aAAa;eAAbA;;IA/BAC,mBAAmB;eAAnBA;;;AAtBT,SAASF,mBAAsBG,SAAc,EAAEC,MAAe;IACjE,MAAMC,aAAaC,MAAMC,OAAO,CAACH,UAAUA,SAAS;QAACA;KAAO;IAE5D,MAAMI,WAAWH,WAAWI,MAAM,CAAC,CAACC,MAAQ,CAACP,UAAUQ,QAAQ,CAACD;IAEhE,OAAO;QAACF,SAASI,MAAM,KAAK;QAAGJ;KAAS;AAC5C;AAgBO,SAASN,oBACZC,SAAgB,EAChBU,aAAgC,EAChCC,aAAiC;IAEjC,MAAMC,SAAgB,EAAE;IACxBD,gBAAgBA,0BAAAA,2BAAAA,gBAAiBD;IACjCP,MAAMC,OAAO,CAACM,iBAAiBA,gBAAgB;QAACA;KAAc;IAC9DP,MAAMC,OAAO,CAACO,iBAAiBA,gBAAgB;QAACA;KAAc;IAE9D,IAAID,cAAcD,MAAM,IAAIE,cAAcF,MAAM,EAAE;QAC9C,MAAM,IAAII,MAAM;IACpB;IACAb,UAAUc,GAAG,CAAC,CAACP;QACX,MAAMQ,MAA8B,CAAC;QACrC,IAAK,IAAIC,IAAI,GAAGA,IAAIN,cAAcD,MAAM,EAAEO,IAAK;YAC3CD,GAAG,CAAC,CAAC,EAAEL,aAAa,CAACM,EAAE,CAAC,CAAC,CAAC,GAAGT,GAAG,CAAC,CAAC,EAAEI,aAAa,CAACK,EAAE,CAAC,CAAC,CAAC;QAC3D;QACAJ,OAAOK,IAAI,CAACF;IAChB;IACA,OAAOH;AACX;AAUO,SAASd,cAAcoB,MAAW,EAAEC,UAAoB;IAC3D,MAAMC,SAAiC,CAAC;IACxC,IAAK,IAAIJ,IAAI,GAAGA,IAAIG,WAAWV,MAAM,EAAEO,IAAK;QACxCI,MAAM,CAAC,CAAC,EAAED,UAAU,CAACH,EAAE,CAAC,CAAC,CAAC,GAAGE,MAAM,CAAC,CAAC,EAAEC,UAAU,CAACH,EAAE,CAAC,CAAC,CAAC;IAC3D;IACA,OAAOI;AACX"}