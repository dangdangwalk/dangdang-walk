{"version":3,"sources":["../../../src/auth/token/token.service.ts"],"sourcesContent":["import { Injectable } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { JwtService } from '@nestjs/jwt';\n\nimport { parse } from '../../utils/ms.util';\nimport { OauthProvider } from '../types/oauth-provider.type';\n\nexport interface AccessTokenPayload {\n    userId: number;\n    provider: OauthProvider;\n}\n\nexport interface RefreshTokenPayload {\n    oauthId: string;\n    provider: OauthProvider;\n}\n\ntype TokenType = 'access' | 'refresh';\ntype TokenExpiryMap = {\n    [key in TokenType]: {\n        expiresIn: string;\n        maxAge: number; // [ms]\n    };\n};\n\n@Injectable()\nexport class TokenService {\n    static TOKEN_LIFETIME_MAP: TokenExpiryMap;\n\n    constructor(\n        private readonly jwtService: JwtService,\n        private readonly configService: ConfigService,\n    ) {\n        const ACCESS_TOKEN_LIFETIME = this.configService.get<string>('ACCESS_TOKEN_LIFETIME', '1h');\n        const REFRESH_TOKEN_LIFETIME = this.configService.get<string>('REFRESH_TOKEN_LIFETIME', '14d');\n\n        TokenService.TOKEN_LIFETIME_MAP = {\n            access: { expiresIn: ACCESS_TOKEN_LIFETIME, maxAge: parse(ACCESS_TOKEN_LIFETIME) },\n            refresh: { expiresIn: REFRESH_TOKEN_LIFETIME, maxAge: parse(REFRESH_TOKEN_LIFETIME) },\n        };\n    }\n\n    async signAccessToken(userId: number, provider: OauthProvider) {\n        const payload: AccessTokenPayload = {\n            userId,\n            provider,\n        };\n\n        const newToken = await this.jwtService.signAsync(payload, {\n            expiresIn: TokenService.TOKEN_LIFETIME_MAP.access.expiresIn,\n        });\n\n        return newToken;\n    }\n\n    async signRefreshToken(oauthId: string, provider: OauthProvider) {\n        const payload: RefreshTokenPayload = {\n            oauthId,\n            provider,\n        };\n\n        const newToken = await this.jwtService.signAsync(payload, {\n            expiresIn: TokenService.TOKEN_LIFETIME_MAP.refresh.expiresIn,\n        });\n\n        return newToken;\n    }\n\n    async verify(token: string): Promise<AccessTokenPayload | RefreshTokenPayload> {\n        const payload = await this.jwtService.verifyAsync(token, {\n            ignoreExpiration: false,\n        });\n\n        if ('userId' in payload) {\n            payload.userId = parseInt(payload.userId);\n        }\n\n        return payload;\n    }\n}\n"],"names":["TokenService","signAccessToken","userId","provider","payload","newToken","jwtService","signAsync","expiresIn","TOKEN_LIFETIME_MAP","access","signRefreshToken","oauthId","refresh","verify","token","verifyAsync","ignoreExpiration","parseInt","constructor","configService","ACCESS_TOKEN_LIFETIME","get","REFRESH_TOKEN_LIFETIME","maxAge","parse","Injectable"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";+BA0BaA;;;eAAAA;;;wBA1Bc;wBACG;qBACH;wBAEL;;;;;;;;;;AAsBf,IAAA,AAAMA,eAAN,MAAMA;IAgBT,MAAMC,gBAAgBC,MAAc,EAAEC,QAAuB,EAAE;QAC3D,MAAMC,UAA8B;YAChCF;YACAC;QACJ;QAEA,MAAME,WAAW,MAAM,IAAI,CAACC,UAAU,CAACC,SAAS,CAACH,SAAS;YACtDI,WAAWR,aAAaS,kBAAkB,CAACC,MAAM,CAACF,SAAS;QAC/D;QAEA,OAAOH;IACX;IAEA,MAAMM,iBAAiBC,OAAe,EAAET,QAAuB,EAAE;QAC7D,MAAMC,UAA+B;YACjCQ;YACAT;QACJ;QAEA,MAAME,WAAW,MAAM,IAAI,CAACC,UAAU,CAACC,SAAS,CAACH,SAAS;YACtDI,WAAWR,aAAaS,kBAAkB,CAACI,OAAO,CAACL,SAAS;QAChE;QAEA,OAAOH;IACX;IAEA,MAAMS,OAAOC,KAAa,EAAqD;QAC3E,MAAMX,UAAU,MAAM,IAAI,CAACE,UAAU,CAACU,WAAW,CAACD,OAAO;YACrDE,kBAAkB;QACtB;QAEA,IAAI,YAAYb,SAAS;YACrBA,QAAQF,MAAM,GAAGgB,SAASd,QAAQF,MAAM;QAC5C;QAEA,OAAOE;IACX;IAjDAe,YACI,AAAiBb,UAAsB,EACvC,AAAiBc,aAA4B,CAC/C;aAFmBd,aAAAA;aACAc,gBAAAA;QAEjB,MAAMC,wBAAwB,IAAI,CAACD,aAAa,CAACE,GAAG,CAAS,yBAAyB;QACtF,MAAMC,yBAAyB,IAAI,CAACH,aAAa,CAACE,GAAG,CAAS,0BAA0B;QAExFtB,aAAaS,kBAAkB,GAAG;YAC9BC,QAAQ;gBAAEF,WAAWa;gBAAuBG,QAAQC,IAAAA,aAAK,EAACJ;YAAuB;YACjFR,SAAS;gBAAEL,WAAWe;gBAAwBC,QAAQC,IAAAA,aAAK,EAACF;YAAwB;QACxF;IACJ;AAuCJ;AArDavB;IADZ0B,IAAAA,kBAAU;;;eAK0B,eAAU,4BAAV,eAAU;eACP,qBAAa,4BAAb,qBAAa;;GALxC1B"}